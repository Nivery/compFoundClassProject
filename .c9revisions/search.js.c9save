{"ts":1351873965825,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"function searchMedia(media_to_search) {\n    // search_terms is an array of terms the user wants to search for. We initialize it here to have it ready.\n\tvar search_terms = [];\n\t\n\tvar search_type = document.getElementById('search_type').selectedIndex;\n\t\n\t// search_indices stores the index number of objects in library_content that match any terms in search_terms\n\t// Having the index numbers make sorting fun and easy.\n\tvar search_indices = [];\n\n\t// count is used to count the number of times search terms appear in each object. It is used by recur\n\tvar count = 1;\n\t\n\t// recur is used to keep track of the number of times search terms appear in each object \n\t// and is used to rank search results by term frequency in search_results\n\tvar recur = [];\n\t\n\tvar search_results = [];\n\t\n\t// If user input is not empty or only white space, split input at whitespace and assign the resulting terms to search_terms\n\t// We do this to prevent a user from entering nothing or a space and returning the entire catalog\n\tif (document.getElementById('search').value !== '' && document.getElementById('search').value.match(/\\S/)) {\n\t\tsearch_terms = document.getElementById('search').value.split(/\\s+/);\n\t} else {\n\t\treturn;\n\t}\n\t\n\t//------LOOK FOR STUFF-------\n\t// For each term in the user's input string, check to see if that term matches any \n\t// of the properties of every object in the library_content array\n\tif (search_type === 0) {\n\t\tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\t// for each (variable in object) is a nifty way to iterate over the value of each object property\n\t\t\t\tfor each (x in library_content[a]) {\n\t\t\t\t\tif (x.match(term)) {\n\t\t\t\t\t\tsearch_indices.push(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (search_type === 1) {\n\t\tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].creator.match(term)) {\n\t\t\t\t\tsearch_indices.push(a);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (search_type === 2) {\n\t\tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].title.match(term)) {\n\t\t\t\t\tsearch_indices.push(a);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (search_type === 3) {\n\t\tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].year.match(term)) {\n\t\t\t\t\tsearch_indices.push(a);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//------RANK SEARCH RESULTS-------\n\t//Sort the search_indices array so that all occurrences of an index are contiguous\n\t//The default sort sorts the numbers by their lexical rather than numerical value\n\tsearch_indices.sort();\n\t\n\t//Set up an array that will track where each index group begins in search_indicies and how many members each group has\n\tfor (var i = 0; i < search_indices.length; i++) {\n\t\t//If the current element matches the next one, increment counter to keep track of the number of matching elements\n\t\tif (search_indices[i] === search_indices[i + 1]) {\n\t\t\tcount++;\n\t\t} else {\n\t\t\t// Push an array with two elements into our recur array\n\t\t\t// The first element in the two-part array is index of the first element in a set of one or more matching indices\n\t\t\t// The second element is the number of elements after the index that match it (Should change to end index for slice function?)\n\t\t\trecur.push([i - (count - 1), count]);\n\t\t\t// Reset the counter for the next go around\n\t\t\tcount = 1;\n\t\t}\n\t}\n\t// Sort recur by the number of elements in each index group (aka sort numerically from high to low by the second element in each of recur's sub-arrays)\n\trecur.sort(function(a,b) {return b[1] - a[1]});\n\t\n\n\t// Prep for output\t\n\tfor (var i = 0; i < recur.length; i++) {\n\t\tsearch_results.push(library_content[search_indices[recur[i][0]]]);\n\t}\n\t\n\tdisplayMedia(search_results);\n}"]],"start1":0,"start2":0,"length1":0,"length2":4392}]],"length":4392}
{"contributors":[],"silentsave":false,"ts":1351873967251,"patch":[[{"diffs":[[1,"function searchMedia(media_to_search) {\n    // search_terms is an array of terms the user wants to search for. We initialize it here to have it ready.\n\tvar search_terms = [];\n\t\n\tvar search_type = document.getElementById('search_type').selectedIndex;\n\t\n\t// search_indices stores the index number of objects in library_content that match any terms in search_terms\n\t// Having the index numbers make sorting fun and easy.\n\tvar search_indices = [];\n\n\t// count is used to count the number of times search terms appear in each object. It is used by recur\n\tvar count = 1;\n\t\n\t// recur is used to keep track of the number of times search terms appear in each object \n\t// and is used to rank search results by term frequency in search_results\n\tvar recur = [];\n\t\n\tvar search_results = [];\n\t\n\t// If user input is not empty or only white space, split input at whitespace and assign the resulting terms to search_terms\n\t// We do this to prevent a user from entering nothing or a space and returning the entire catalog\n\tif (document.getElementById('search').value !== '' && document.getElementById('search').value.match(/\\S/)) {\n\t\tsearch_terms = document.getElementById('search').value.split(/\\s+/);\n\t} else {\n\t\treturn;\n\t}\n\t\n\t//------LOOK FOR STUFF-------\n\t// For each term in the user's input string, check to see if that term matches any \n\t// of the properties of every object in the library_content array\n\tif (search_type === 0) {\n\t\tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\t// for each (variable in object) is a nifty way to iterate over the value of each object property\n\t\t\t\tfor each (x in library_content[a]) {\n\t\t\t\t\tif (x.match(term)) {\n\t\t\t\t\t\tsearch_indices.push(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (search_type === 1) {\n\t\tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].creator.match(term)) {\n\t\t\t\t\tsearch_indices.push(a);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (search_type === 2) {\n\t\tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].title.match(term)) {\n\t\t\t\t\tsearch_indices.push(a);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (search_type === 3) {\n\t\tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].year.match(term)) {\n\t\t\t\t\tsearch_indices.push(a);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//------RANK SEARCH RESULTS-------\n\t//Sort the search_indices array so that all occurrences of an index are contiguous\n\t//The default sort sorts the numbers by their lexical rather than numerical value\n\tsearch_indices.sort();\n\t\n\t//Set up an array that will track where each index group begins in search_indicies and how many members each group has\n\tfor (var i = 0; i < search_indices.length; i++) {\n\t\t//If the current element matches the next one, increment counter to keep track of the number of matching elements\n\t\tif (search_indices[i] === search_indices[i + 1]) {\n\t\t\tcount++;\n\t\t} else {\n\t\t\t// Push an array with two elements into our recur array\n\t\t\t// The first element in the two-part array is index of the first element in a set of one or more matching indices\n\t\t\t// The second element is the number of elements after the index that match it (Should change to end index for slice function?)\n\t\t\trecur.push([i - (count - 1), count]);\n\t\t\t// Reset the counter for the next go around\n\t\t\tcount = 1;\n\t\t}\n\t}\n\t// Sort recur by the number of elements in each index group (aka sort numerically from high to low by the second element in each of recur's sub-arrays)\n\trecur.sort(function(a,b) {return b[1] - a[1]});\n\t\n\n\t// Prep for output\t\n\tfor (var i = 0; i < recur.length; i++) {\n\t\tsearch_results.push(library_content[search_indices[recur[i][0]]]);\n\t}\n\t\n\tdisplayMedia(search_results);\n}"]],"start1":0,"start2":0,"length1":0,"length2":4392}]],"length":4392,"saved":false}
{"contributors":[],"silentsave":false,"ts":1351910546686,"patch":[[{"diffs":[[0,"_content array\n\t"],[-1,""],[0,""],[1,"// eventually, I want to make this loop skip the type, age_group, and in_out categories, which can all be handled by filter anyway\n\t"],[0,"if (search_type "]],"start1":1377,"start2":1377,"length1":32,"length2":164},{"diffs":[[0,"terms[i], 'i');\n"],[1,"\n"],[0,"\t\t\tfor (var a = "]],"start1":1727,"start2":1727,"length1":32,"length2":33},{"diffs":[[0,") {\n"],[-1,"\t\t\t\t// for each (variable in object) is a nifty way to iterate over the value of each object property\n\t\t\t\tfor each (x in library_content[a]) {\n\t\t\t\t\tif (x.match(term)) {\n\t\t\t\t\t\tsearch_indices.push(a);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (search_type === 1) {\n\t\tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].creator.match(term)) {\n\t\t\t\t\tsearch_indices.push(a);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (search_type === 2) {\n\t\tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].title.match(term)) {\n\t\t\t\t\tsearch_indices.push(a);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (search_type === 3) {\n\t\tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].year.match(term)) {\n\t\t\t\t\tsearch_indices.push(a);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//------RANK SEARCH RESULTS-------\n\t//Sort the search_indices array so that all occurrences of an index are contiguous\n\t//The default sort sorts the numbers by their lexical rather than numerical value\n\tsearch_indices.sort();\n\t\n\t//Set up an array that will track where each index group begins in search_indicies and how many members each group has\n\tfor (var i = 0; i < search_indices.length; i++) {\n\t\t//If the current element matches the next one, increment counter to keep track of the number of matching elements\n\t\tif (search_indices[i] === search_indices[i + 1]) {\n\t\t\tcount++;\n\t\t} else {\n\t\t\t// Push an array with two elements into our recur array\n\t\t\t// The first element in the two-part array is index of the first element in a set of one or more matching indices\n\t\t\t// The second element is the number of elements after the index that match it (Should change to end index for slice function?)\n\t\t\trecur.push([i - (count - 1), count]);\n\t\t\t// Reset the counter for the next go around\n\t\t\tcount = 1;\n\t\t}\n\t}\n\t// Sort recur by the number of elements in each index group (aka sort numerically from high to low by the second element in each of recur's sub-arrays)\n\trecur.sort(function(a,b) {return b[1] - a[1]});\n\t\n\n\t// Prep for output\t\n\tfor (var i = 0; i < recur.length; i++) {\n\t\tsearch_results.push(library_content[search_indices[recur[i][0]]]);\n\t}\n\t\n\tdisplayMedia(search_results);\n}function searchMedia(media_to_search) {\n    // search_terms is an array of terms the user wants to search for. We initialize it here to have it ready.\n\tvar search_terms = [];\n\t\n\tvar search_type = document.getElementById('search_type').selectedIndex;\n\t\n\t// search_indices stores the index number of objects in library_content that match any terms in search_terms\n\t// Having the index numbers make sorting fun and easy.\n\tvar search_indices = [];\n\n\t// count is used to count the number of times search terms appear in each object. It is used by recur\n\tvar count = 1;\n\t\n\t// recur is used to keep track of the number of times search terms appear in each object \n\t// and is used to rank search results by term frequency in search_results\n\tvar recur = [];\n\t\n\tvar search_results = [];\n\t\n\t// If user input is not empty or only white space, split input at whitespace and assign the resulting terms to search_terms\n\t// We do this to prevent a user from entering nothing or a space and returning the entire catalog\n\tif (document.getElementById('search').value !== '' && document.getElementById('search').value.match(/\\S/)) {\n\t\tsearch_terms = document.getElementById('search').value.split(/\\s+/);\n\t} else {\n\t\treturn;\n\t}\n\t\n\t//------LOOK FOR STUFF-------\n\t// For each term in the user's input string, check to see if that term matches any \n\t// of the properties of every object in the library_content array\n\tif (search_type === 0) {\n\t\tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {"],[0,""],[1,""],[0,"\n\t\t\t"]],"start1":1794,"start2":1794,"length1":4399,"length2":8},{"diffs":[[0,"for "],[-1,"each "],[0,"(x in "],[-1,"library_content"],[1,"media_to_search"],[0,"[a]) {"],[1,";"],[0,"\n\t\t\t"]],"start1":1905,"start2":1905,"length1":40,"length2":36},{"diffs":[[0,"\t\t\t\tif ("],[-1,"x"],[1,"media_to_search[a][x]"],[0,".match(t"]],"start1":1939,"start2":1939,"length1":17,"length2":37},{"diffs":[[0,"\n\t\n\t"],[-1,"display"],[1,"filter"],[0,"Medi"]],"start1":4507,"start2":4507,"length1":15,"length2":14}]],"length":4541,"saved":false}
{"contributors":[],"silentsave":false,"ts":1353447969779,"patch":[[{"diffs":[[0," ready.\n"],[-1,"\t"],[1,"    "],[0,"var sear"]],"start1":143,"start2":143,"length1":17,"length2":20},{"diffs":[[0,"/)) {\n\t\t"],[-1,"search_terms = "],[1,"//create an array of search terms by using a custom function (found below) to split the user input string\n\t\tsearch_terms = splitForSearch("],[0,"document"]],"start1":1110,"start2":1110,"length1":31,"length2":154},{"diffs":[[0,"alue"],[-1,".split(/\\s+/"],[0,");\n\t"]],"start1":1291,"start2":1291,"length1":20,"length2":8},{"diffs":[[0," of the "],[1,"selected "],[0,"properti"]],"start1":1442,"start2":1442,"length1":16,"length2":25},{"diffs":[[0,"ray\n"],[-1,"\t// eventually, I want to make this loop skip the type, age_group, and in_out categories, which can all be handled by filter anyway\n"],[0,"\tif "]],"start1":1511,"start2":1511,"length1":140,"length2":8},{"diffs":[[0,", 'i');\n"],[-1,""],[0,""],[1,"\t\t\t\t"],[0,"\n\t\t\tfor "]],"start1":1726,"start2":1726,"length1":16,"length2":20},{"diffs":[[0," a++) {\n"],[-1,"\n"],[0,"\t\t\t\t// f"]],"start1":1785,"start2":1785,"length1":17,"length2":16},{"diffs":[[0,"ch[a]) {"],[-1,";"],[0,"\n"],[1,"\t\t\t\t\t// exclude object properties from the search that it doesn't really make sense to search\n\t\t\t\t\tif (x !== 'in_out' && x !== 'age_group' && x !== 'type' && x !== 'cover' && x !== 'on_loan') {\n\t"],[0,"\t\t\t\t\tif "]],"start1":1922,"start2":1922,"length1":18,"length2":212},{"diffs":[[0,"m)) {\n\t\t\t\t\t\t"],[1,"\t"],[0,"search_indic"]],"start1":2166,"start2":2166,"length1":24,"length2":25},{"diffs":[[0,");\n\t\t\t\t\t"],[1,"\t"],[0,"}\n"],[1,"\t"],[0,"\t\t\t\t}\n\t\t"]],"start1":2200,"start2":2200,"length1":18,"length2":20},{"diffs":[[0,"\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t"],[-1,"}\n\t\t}"],[1,"\t}\n\t\t\t}\n\t\t}\n\t// Search by creator"],[0,"\n\t} else if (sea"]],"start1":2205,"start2":2205,"length1":37,"length2":65},{"diffs":[[0,"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n"],[1,"\t// Search by title\n"],[0,"\t} else if (sear"]],"start1":2614,"start2":2614,"length1":32,"length2":52},{"diffs":[[0,"\t\t}\n\t\t}\n"],[1,"\t// Search by year\n"],[0,"\t} else "]],"start1":3015,"start2":3015,"length1":16,"length2":35},{"diffs":[[0,"ush("],[-1,"library_content[search_indices[recur[i][0]]]"],[1,"media_to_search[search_indices[recur[i][0]]]);\n\t}\n\t\n\tfilterMedia(search_results);\n}\n\n\n// This ugly little hand-rolled function allows us to treat a quoted string (\"like this one\")\n// as a single search term rather than multiple search terms. Currently, this function only \n// recognizes double-quoted strings as units because that's easier than adding a bit to parse\n// whether a single quote is an apostrophe or quote mark. This behavior may change, if there's time.\n//\n// If a search string includes an unclosed quotation mark (\"quoted string without closing quote) \n// splitForSearch will treat everything after the opening quote as a quoted string. This is either\n// an annoying bug or a nifty short-hand depending on your perspective.\n\nfunction splitForSearch(str_to_split) {\n\t//split the user's input string into an array of single characters\n\tvar split_arr = str_to_split.split('')\n\tvar temp_arr = [];\n\tvar output_arr = [];\n\t\n\twhile (split_arr[0] !== undefined) {\n\t\t// Until we encounter a space pile add any unquoted words to temp_arr, which will become a string later\n\t\tif (split_arr[0].match(/[^\"]/)) {\n\t\t\twhile (split_arr[0] !== undefined && split_arr[0].match(/[^\\s]/)) {\n\t\t\t\ttemp_arr.push(split_arr.shift());\n\t\t\t}\n\t\t\t// Once we encounter a space, dump it out into the ether\n\t\t\tsplit_arr.shift();\n\t\t//pile letters and spaces onto temp_arr to be restringified below\n\t\t} else if (split_arr[0].match(/\"/)) {\n\t\t\t//dump the opening quote\n\t\t\tsplit_arr.shift();\n\t\t\twhile (split_arr[0] !== undefined && split_arr[0].match(/[^\"]/)) {\n\t\t\t\ttemp_arr.push(split_arr.shift()"],[0,");\n"],[1,"\t\t"],[0,"\t}\n\t"],[-1,"\n\tfilterMedia(search_results)"],[1,"\t\t//dump the closing quote\n\t\t\tsplit_arr.shift();\n\t\t// Catch any spaces left after a quoted string, this is safer than dumping shifting two elements off\n\t\t// split_arr in the quoted-string if because it prevents (\"quoted string\"term2) to be ['quoted string', 'term2']\n\t\t// rather than ['quoted string', 'erm2']. This will also catch any spaces missed through other ways.\n\t\t} else if (split_arr[0] !== undefined && split_arr[0].match(/\\s/)) {\n\t\t\tsplit_arr.shift();\n\t\t}\n\t\t// Turn temp_arr into a string and push it onto the output array if it's not empty\n\t\t// Pushing an empty temp_arr onto output_arr will result in a search that matches everything (double-plus ungood)\n\t\tif (temp_arr.length > 0) {\n\t\t\toutput_arr.push(temp_arr.join(''));\n\t\t}\n\t\t//Blank out temp array for the next iteration of the loop\n\t\ttemp_arr = [];\n\t}\n\treturn output_arr"],[0,";\n}"]],"start1":4712,"start2":4712,"length1":87,"length2":2426}]],"length":7138,"saved":false}
{"ts":1353448598759,"patch":[[{"diffs":[[0,"\t}\n\t\t\t}\n\t\t}\n"],[1,"\t} else if (search_type === 4) {\n    \tfor (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].tags.match(term)) {\n\t\t\t\t\tsearch_indices.push(a);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n"],[0,"\t}\n\t\n\t//----"]],"start1":3402,"start2":3402,"length1":24,"length2":399}]],"length":7513,"saved":false}
{"contributors":[],"silentsave":false,"ts":1353698035195,"patch":[[{"diffs":[[1,"// searchMedia() now supports \"multi-word terms in double quotes\" and terms a user wishes to -exclude\n// by prepending such term with a hyphen/minus/negative \n"],[0,"function searchM"]],"start1":0,"start2":0,"length1":16,"length2":175},{"diffs":[[0,"eturn;\n\t}\n\t\n"],[1,"\tvar exclude = [];\n\tvar field_to_search = '';\n\t\n\t// If a search term is prefaced with a hyphen, add it to the exclude list, otherwise, treat it like a \n\t// regular search term.\n\tfor (var i = 0; i < search_terms.length; i++) {\n\t\tif (search_terms[i].match(/^-/)) {\n\t\t\tmustnt = new String(search_terms.splice(i,1));\n\t\t\texclude.push(new RegExp(mustnt.substr(1), 'i'));\n\t\t} else { \n\t\t\tsearch_terms[i] = new RegExp(search_terms[i], 'i');\n\t\t}\n\t}\n"],[0,"\t//------LOO"]],"start1":1470,"start2":1470,"length1":24,"length2":463},{"diffs":[[0,"\tvar term = "],[-1,"new RegExp("],[0,"search_terms"]],"start1":2286,"start2":2286,"length1":35,"length2":24},{"diffs":[[0,"rch_terms[i]"],[-1,", 'i')"],[0,";\n\t\t\t\t\n\t\t\tfo"]],"start1":2301,"start2":2301,"length1":30,"length2":24},{"diffs":[[0,") {\n"],[-1,"\t\t\t\t// for each (variable in object) is a nifty way to iterate over the value of each object property\n"],[0,"\t\t\t\t"]],"start1":2370,"start2":2370,"length1":110,"length2":8},{"diffs":[[0,"}\n\t\t"],[-1,"}\n"],[0,"\t// "],[-1,"Search by creator\n\t} else if (search_type === 1"],[1,"Remove any matches that include unwanted terms\n\t\t\tif (exclude.length > 0) {\n\t\t\t\tfor (var q = 0; q < exclude.length; q++"],[0,") {\n"],[1,"\t\t\t"],[0,"\t\tfo"]],"start1":2706,"start2":2706,"length1":65,"length2":138},{"diffs":[[0,"= 0; i < search_"],[-1,"term"],[1,"indice"],[0,"s.length; i++) {"]],"start1":2853,"start2":2853,"length1":36,"length2":38},{"diffs":[[0,"+) {"],[-1,"\t"],[0,"\n\t\t\t"],[-1,"// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].creator.match(term)"],[1,"\t\t\tfor (var x in media_to_search[search_indices[i]]) {\n\t\t\t\t\t\t\t// Have to make sure media_to_search[search_indices[i]][x] isn't undefined or this'll throw an error and crash.\n\t\t\t\t\t\t\tif (media_to_search[search_indices[i]][x] !== undefined && media_to_search[search_indices[i]][x].match(exclude[q]) && x !== 'in_out' && x !== 'age_group' && x !== 'type' && x !== 'cover' && x !== 'on_loan'"],[0,") {\n"],[1,"\t\t\t"],[0,"\t\t\t\t"]],"start1":2887,"start2":2887,"length1":256,"length2":405},{"diffs":[[0,"rch_indices."],[-1,"push(a);\t"],[1,"splice(i, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}"],[0,"\n\t\t\t\t}\n\t\t\t}\n"]],"start1":3296,"start2":3296,"length1":33,"length2":61},{"diffs":[[0,"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n"],[1,"\t} else {\n"],[0,"\t// Search by ti"]],"start1":3345,"start2":3345,"length1":32,"length2":42},{"diffs":[[0," by "],[-1,"title\n\t} else "],[1,"creator\n\t\t"],[0,"if ("]],"start1":3381,"start2":3381,"length1":22,"length2":18},{"diffs":[[0,"=== "],[-1,"2"],[1,"1"],[0,") {\n\t\t"],[-1,"for (var i = 0; i < search_terms.length; i++) {\t\n\t\t\t// convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].title.match(term)) {\n\t\t\t\t\tsearch_indices.push(a);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t// S"],[1,"\tfield_to_search = 'creator';\n\t\t} else if (search_type === 2) {\n\t\t\tfield_to_search = 'title';\n\t\t} else if (search_type === 3) {\n\t\t\tfield_to_s"],[0,"earch "],[-1,"by "],[1,"= '"],[0,"year"],[-1,"\n"],[1,"';\n\t"],[0,"\t} e"]],"start1":3411,"start2":3411,"length1":372,"length2":173},{"diffs":[[0,"ype === "],[-1,"3"],[1,"4"],[0,") {\n"],[1,"\t\t\tfield_to_search = 'tags';\n\t\t}\n"],[0,"\t\tfor (v"]],"start1":3600,"start2":3600,"length1":21,"length2":54},{"diffs":[[0,"\tvar term = "],[-1,"new RegExp("],[0,"search_terms"]],"start1":3793,"start2":3793,"length1":35,"length2":24},{"diffs":[[0," search_terms[i]"],[-1,", 'i')"],[0,";\n\t\t\tfor (var a "]],"start1":3804,"start2":3804,"length1":38,"length2":32},{"diffs":[[0,"h[a]"],[-1,".year"],[1,"[field_to_search]"],[0,".mat"]],"start1":3898,"start2":3898,"length1":13,"length2":25},{"diffs":[[0,"\t}\n\t"],[-1,"} else if (search_type === 4) {\n    \tfor (var i = 0; i < search_terms.length; i++"],[1,"\tif (exclude.length > 0) {\n\t\t\tfor (x in exclude"],[0,") {"],[-1,"\t"],[0,"\n"],[1,"\t"],[0,"\t\t\t// "],[-1,"convert the search term into a regular expression for case-insensitive partial matching\n\t\t\tvar term = new RegExp(search_terms[i], 'i');\n\t\t\tfor (var a = 0; a < media_to_search.length; a++) {\n\t\t\t\tif (media_to_search[a].tags.match(term"],[1,"Check if media_to_search[search_indices[i]] is undefined so as not to throw errors and die\n\t\t\t\t// If something is on our no-no list, remove it from search results\n\t\t\t\tif (media_to_search[search_indices[i]] !== undefined && media_to_search[search_indices[i]][field_to_search].match(exclude[x]"],[0,")) {"]],"start1":3977,"start2":3977,"length1":332,"length2":357},{"diffs":[[0,"rch_indices."],[-1,"push(a"],[1,"splice(i, 1"],[0,");"],[-1,"\t"],[0,"\n\t\t\t\t}\n\t\t\t}\n"]],"start1":4343,"start2":4343,"length1":33,"length2":37},{"diffs":[[0,"e's time"],[-1,""],[0,""],[1,".\n// Actually, tested single quotes against 5 search engines. None treated single quotes like double quotes,\n// so probably not 'fixing' this since it's industry standard behavior"],[0,".\n//\n// "]],"start1":6144,"start2":6144,"length1":16,"length2":195}]],"length":8287,"saved":false}
